# Agile Principles

## The 12 Principles of Agile Software
1. Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.
2. Welcome changing requirements, even late in development. Agile processes harness change for the customer’s competitive advantage.
3. Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.
4. The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.
5. Business people and developers must work together daily throughout the project.
6. Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.
7. Working software is the primary measure of progress.
8. Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.
9. Continuous attention to technical excellence and good design enhances agility.
10. Simplicity—the art of maximizing the amount of work not done—is essential.
11. The best architectures, requirements, and designs emerge from self-organizing teams.
12. At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.

The motivation behind the 12 principles: getting the team to build software that the user actually needs. The principles depend on the idea that we build projects to deliver value. But that word, 'value', is a little bit tricky, because everyone sees different value in the software.

For example: handheld ebook reader
* As a reader, you want the software to make the book easy to read. You care about being able to flip back and forth between pages, highlight sections or take notes, search for text, and keep track of the last page you read.
* As authors, we care very much that the words we write are displayed correctly, that these bullet points are indented so that they're easy for you to read, that it’s easy for you to navigate back and forth between the body text and the footnotes, and that you have a good overall experience so you can enjoy and learn from what we write.
* Our editor at O’Reilly cares that it’s easy to distribute the book to you, and that, if you like it, you have an easy way to give it a positive review and buy other books from O’Reilly.
* The bookseller or retailer who sold you this book wants to make it very easy for you to browse and buy other books they have for sale, and to download them quickly and easily to your reader.

It’s easy to see the value that an ebook reader has delivered, because hindsight is 20/20. It’s much harder to see that value at the start of the project.

### Principle 1
This first principle includes three distinct and important ideas: releasing software early, delivering value continuously, and satisfying the customer.

The customer can only give you real, informed feedback after seeing working software, then the best way to get that feedback is through **early delivery**. Because the software works, and because the customers can actually use it to do something they need, the team has delivered real value.

The downside to delivering early is that the software that’s first delivered to the customers is far from complete. This can be really hard for some users and stakeholders to deal with.

The core agile values have an answer to this: customer collaboration over contract negotiation. A team that's bound to a fixed specification with inflexible bureaucratic barriers to change doesn't have the option to let the software evolve over time. A team working under those conditions has to kick off a whole new change management process, which requires a fresh set of contract negotiations with the customer. On the other hand, a team that truly collaborates with the customers has the option of making all the necessary changes along the way. That's what **continuous delivery** means.

This is why agile methodologies are typically iterative. Agile teams plan the project’s iterations by choosing the features and requirements that will deliver the most value. The only way that the team can figure out what features deliver that value is to collab‐ orate with the customer and incorporate the feedback from the previous iteration. This lets the team satisfy the customer in the short run by demonstrating value early.

### Princple 2
Why are changes in a project emotionally charged? Understanding that is a key to this principle. A change is someone outside of the project telling you that some of the planning and work youd did was wrong—that you were wrong.

Most software engineers are driven by pride of workmanship: we want to deliver products that we can stand behind, and that satisfy our users’ needs. A change in a project threatens that, because it’s questioning the path that you’ve taken and the assumptions that you've made.

What does it mean to welcome change? It means:
* Nobody gets in “trouble” when there’s a change. We acknowledge—and our bosses acknowledge—that we’re human and fallible, and that it’s better for the company to allow us to make mistakes and correct them frequently, rather than expect us to do things perfectly the first time.
* We’re all in this together. Everyone on the team, including the customers you’re collaborating with, owns the requirements and the changes to those require‐ ments. If those requirements are wrong, it’s as much your fault as the customer’s, so there’s no sense in placing blame for a change.
* We don’t sit on change until it’s too late. Yes, it’s embarrassing to have made a mistake. But because we all recognize that, we simply do our best to fix it as early as possible. That way, the damage is limited.
* We stop thinking of changes as mistakes. We did our best with the information we had at the time, and it only became clear that we were wrong because the decisions we made along the way gave us the perspective to recognize the changes that we have to make today.
* We learn from the changes. This is the most effective way for a team to grow and get better at building software together.

### Principle 3
Agile practitioners refer to the traditional attitude toward project changes as **command-and-control**.

Command-and-control project management is similar to military command-and- control:
* 'Command' refers to the way the project manager assigns work to the team. The team may not report directly to her, but she has control over their assignments. She breaks down the work, builds a schedule, and assigns activities to the resour‐ ces on her team.
* 'Control' refers to the way she manages changes. Every project has changes along the way: work takes longer than anticipated, people take sick days or leave the project, hardware is not available or breaks, and all sorts of other unexpected things happen. Project managers constantly monitor for these changes, and then control the project by evaluating each change as it occurs, updating the plans to incorporate the change into the schedule and documentation, giving the team new assignments, and managing their stakeholders’ expectations so that nobody is blindsided.

If agile teams don’t use command-and-control, how do they manage to keep up with all of those changes?

The key to welcoming changes without introducing chaos lies in delivering working software frequently. The team uses iteration to break the project into regular dead‐ lines. During the iterations, the team delivers working software. At the end of each iteration, the team holds a demo to show the customer what they built, and a retro‐ spective to look back and see what lessons can be learned. Then they start a planning session to figure out what they’ll build in the next iteration. The predictable schedule and the constant checkpoints help the team catch those changes early, and give every‐ one a blame-free environment where they can discuss each change and come up with a strategy to incorporate it into the project.

The project manager’s role starts to shift away from command-and-control, where she gave the team a daily battle plan and constantly adjusted to keep them on track. Instead, now she’s working with the team to make sure that each person is constantly looking at the big picture and working toward the same goals. It’s easier to do that when the team is working on a short iteration that will deliver working software.

### Principle 4
Agile teams communicate most effectively when they focus on face-to-face conversation and rely on the minimum amount of documentation necessary for the project.

### Principle 5
To build software well, teams need to have a lot of face-to-face discussion with businesspeople, because they need to tap into their knowledge of the company’s problems that are going to be solved with software.

When businesspeople and developers build software as a team, it’s most efficient in the long run to work together daily throughout the project. That’s because the alter‐ native is to have the businesspeople wait until late in the project to look over the team’s work and give feedback, and it’s much more expensive to make changes at the end of the project.

### Princile 6
Projects run best when everyone in the company recognizes that the team is building valuable software, and when everyone on the team—including the product owner— understands what makes the software valuable to the company.

Ultimately, everyone’s performance should be based on what the team delivers, rather than the specific role that they played in it.

A good environment for a team will reward a programmer who recognizes a part of the business problem that isn’t being addressed and fixes it, or a tester who sees a problem with the code or architecture and raises that with the team.

Comprehensive documentation and traceability matrices are a particularly insidious source of problems with a team’s environment and support. Instead of encouraging an environment of trust, they encourage a “cover your ass” (CYA) attitude in which teams move toward a “contract negotiation” approach, rather than customer collabo‐ ration. A tester with a CYA attitude will spend time making sure every requirement has a test, whether or not it does anything to actually help the quality of the software. Developers will CYA by adhering to the letter of the requirement, without bothering to think about whether or not it actually delivers value to the users—because if they’re working in a CYA environment, trying to build what the customer actually needs can get them dinged for not building the software to spec. Business analysts and product owners will CYA by spending their time making sure that the scope and requirements line up perfectly, and often find themselves tempted to omit pesky requirements that don’t align perfectly with the existing documentation, regardless of their value.

The opposite of CYA is trust. A company that develops only the minimal documentation needed for the project has an environment where the team is trusted to do the right thing when a change happens. An agile team with a “we’re all in this together” attitude, where if the project fails everyone shares the blame, doesn’t need to CYA. It’s easier for them to handle changes, because they don’t need to maintain all of that unnecessary documentation. Instead, they can tackle the actual problem with face-to- face communication, and only write down what’s necessary. And they can do this knowing that the company trusts that they’re doing the right thing—even if it causes the project to take longer.

### Principle 7
A good team works to make sure that everyone—team members, managers, stake‐ holders, and customers—really understands where the project is at any time. But how do you actually communicate the status of a project? The answer lies in working software. Working software is better than progress reports for giving everyone the latest update on the project's status, because it's the most effective way for the team to communicate what they've accomplished.

This is one reason why agile teams use iterative development. By delivering working software at the end of each iteration, and by doing a real product demonstration that shows everyone exactly what the team did, they keep everyone up to date on the pro‐ gress of the software in a way that is almost impossible to misread.

### Principle 8
This is why agile teams believe in maintaining a sustainable pace. They should plan on delivering work that can actually be done in the time they reserve for it. Iterative development makes this more realistic, because it’s a lot easier to estimate how much software they can deliver in the next two, four, or six weeks than it is to estimate how much they can deliver in the next year and a half.

Teams are most productive when they work at a sustainable pace and avoid heroics, shortcuts, and overtime.

### Principle 9
The last two decades or so have brought us a revolution in software design. Object- oriented design and analysis, design patterns, decoupled and service-oriented archi‐ tecture, and other innovations have given developers patterns and tools to bring technical excellence to every project.

But this doesn’t mean that agile teams spend a lot of time creating large-scale designs at the start of every software project. Agile developers build up great coding habits that help them create well-designed code. They’re constantly on the lookout for design and code problems, and take the time to fix those problems as soon as they’re discovered.

### Principle 10
Adding code to an existing project often makes it more complex, especially when you then add even more code that depends on it. Dependencies between systems, objects, services, etc., make code more complex and difficult to change: the dependencies increase the likelihood of one change cascading out to another part of the system, which then requires changes to a third part of the system, creating a domino effect of increasing complexity for every change.

Maximizing the amount of work not done means avoiding this mess—and the best way to do this is by building systems that don’t have a lot of dependencies and unnec‐ essary code. The most effective way to do this is to work with your customers and stakeholders to only build the most useful and valuable software. When teams write code, they can keep their software designs simple by creating software designs based on small, self-contained units (like classes, modules, services, etc.) that do only one thing; this helps avoid the domino effect.

### Principle 11
A self-organizing team does not have an explicit requirements or design phase. When a team is self-organizing, it means that they work together to plan the project (instead of relying on a single person who 'owns' the plan), and they continually come together as a team to revise that plan. A team that works like this typically breaks the project down into user stories or other small chunks, and starts working on the ones that deliver the most value to the company first. Only then do they start thinking about detailed requirements, design, and architecture.

On an agile team, everyone shares responsibility for the architecture. A senior soft‐ ware architect or designer still has an important role to play—but it is no longer one where he or she can work in isolation.

Instead of creating one big design at the beginning of the project that covers all of the requirements, agile architects use incremental design, which involves techniques that allow them to design a system that is not just complete, but also easy for the team to modify as the project changes.


### Princple 12
A team isn’t agile until they’re constantly improving the way they build software. Agile teams constantly inspect and adapt—they look at how their projects have run, and they use that knowledge to improve in the future. And they don’t just do this at the end of the project; when they meet every day, they look for ways to change, and they’ll change the work that they’re currently doing if it makes sense.

## The Agile Project: Bringing All the Principles Together
The key to using agile practices together is the mindset that the team brings to the project—and that mindset is driven by the agile values and principles. Agile is different because it starts with values and principles. A team going agile has to look honestly not just at the way they build software, but also at the way they inter‐ act with each other and the rest of their company.
